/*
 * 
 */
package computation.parser;

import computation.contextfreegrammar.*;
import computation.parsetree.ParseTreeNode;

/**
 * Your parser class should implement this interface.
 * 
 * There is an example empty class already, but you're welcome
 * to create a new one (and probably should when you try the
 * second algorithm).
 */
public interface IParser {

	/**
	 * Checks if the given word is in the language generated
	 * by this grammar. This is a method you have to write.
	 * <p>
	 * As part of finding the parse tree that generates a given word,
	 * you will necessarily find whether it is part of the language.
	 * But this task is slightly easier, so you might want to start here.
	 * <p>
	 * If you manage to complete the parse tree part, you can always write:
	 * <blockquote><pre>
	 * public boolean isInLanguage(ContextFreeGrammar cfg, Word w) {
	 * 	   return generateParseTree(ContextFreeGrammar cfg, Word w) != null;
	 * }
	 * </pre></blockquote>
	 * 
	 * @param cfg the context free grammar
	 * @param w the word to test
	 * @return true, if this word is generated by this grammar
	 */
	boolean isInLanguage(ContextFreeGrammar cfg, Word w);

	/**
	 * Generates a parse tree for a given word in a given grammar.
	 * This is a method you have to write.
	 * <p>
	 * Return null if the Word is not a member of the language. This method
	 * must work <i>without</i> having to call isInLanguage first.
	 * <p>
	 * You should look at {@link ParseTreeNode the ParseTreeNode class} to
	 * understand how to actually create a parse tree. In particular, look at
	 * the {@link ParseTreeNode#main(String[]) main method}.
	 *
	 * @param cfg the context free grammar
	 * @param w the word to test
	 * @return the parse tree node at the root of the parse tree which generates
	 * this word in the given grammar. 
	 */
	ParseTreeNode generateParseTree(ContextFreeGrammar cfg, Word w);

}
